import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class HostDiscovery {
    private final int timeout;

    private final String startIp;
    private final String endIp;
    private final ArrayList<Host> hosts = new ArrayList<>();

    public HostDiscovery(String startIp, String endIp, int timeout){
        this.startIp = startIp;
        this.endIp = endIp;

        this.timeout = timeout;
    }

    public HostDiscovery(String ip, int timeout){
        this.startIp = ip;
        this.endIp = null;

        this.timeout = timeout;
    }

    public static boolean validateIP(String ip){
        String zeroTo255 = "(\\d{1,2}|(0|1)\\d{1,2}|2[0-4]\\d|25[0-5])";
        return ip.matches(zeroTo255+"\\."+zeroTo255+"\\."+zeroTo255+"\\."+zeroTo255);
    }

    public ArrayList<Host> discoverHosts(boolean threaded) throws IOException {

        if(!validateIP(this.startIp)){
            return this.hosts;
        }

        if(this.endIp == null){
            InetAddress addr = null;

            try{
                addr = InetAddress.getByName(this.startIp);

            } catch (UnknownHostException e){
                System.err.println("Unknown Host: " + e);

            }

            if(addr != null && addr.isReachable(this.timeout)){
                this.hosts.add(new Host(this.startIp));

            }

        }
        else{
            String[] startAddrOctets = this.startIp.split("\\.");
            String[] endAddrOctets = this.endIp.split("\\.");

            int range = Integer.parseInt(endAddrOctets[3]) - Integer.parseInt(startAddrOctets[3]);

            if(range < 1) {
                return this.hosts;
            }

            String network = startAddrOctets[0] + "." + startAddrOctets[1] + "." + startAddrOctets[2] + ".";
            int poolSize = range / 5;

            if(threaded && poolSize > 1){

                ConcurrentLinkedQueue<String> hostsToSearch = new ConcurrentLinkedQueue<>();
                ExecutorService es = Executors.newFixedThreadPool(poolSize);
                AtomicInteger hostNumber = new AtomicInteger(Integer.parseInt(startAddrOctets[3]));

                while(hostNumber.get() <= Integer.parseInt(endAddrOctets[3])){
                    final String host = network + hostNumber.getAndIncrement();

                    es.submit(() -> {
                        try {

                            InetAddress addr = InetAddress.getByName(host);
                            if(addr.isReachable(200)){
                                hostsToSearch.add(host);
                            }

                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }

                    });

                }

                es.shutdown();
                try {
                    es.awaitTermination(1, TimeUnit.MINUTES);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }

                while (!hostsToSearch.isEmpty()) {
                    this.hosts.add(new Host(hostsToSearch.poll()));
                }

                return this.hosts;

            } else {
                for (int i = 0; i < range; ++i) {
                    String ip = network + i;
                    InetAddress addr = InetAddress.getByName(ip);
                    boolean isReachable = addr.isReachable(this.timeout);

                    if (isReachable) {
                        hosts.add(new Host(ip));
                    }

                }

            }

        }

        return this.hosts;

    }

}
