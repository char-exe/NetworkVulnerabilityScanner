import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class HostDiscovery {

    // Set ping timeout (ms)
    private final int timeout;

    // Start of IP address range
    private final String startIp;

    // End of IP address range
    private final String endIp;

    // List to store connected hosts
    private final ArrayList<Host> hosts = new ArrayList<>();

    // Constructor for IP address range
    public HostDiscovery(String startIp, String endIp, int timeout){
        this.startIp = startIp;
        this.endIp = endIp;
        this.timeout = timeout;
    }

    // Constructor for single IP host discovery
    public HostDiscovery(String ip, int timeout){
        this.startIp = ip;
        this.endIp = null;

        this.timeout = timeout;
    }

    /**
     * Regex match input IP address
     * @param ip: Given IP string
     * @return True if IP is valid, False otherwise
     */
    public static boolean validateIP(String ip){
        String zeroTo255 = "(\\d{1,2}|[0-1]\\d{1,2}|2[0-4]\\d|25[0-5])";
        return ip.matches(zeroTo255+"\\."+zeroTo255+"\\."+zeroTo255+"\\."+zeroTo255);
    }

    /**
     * Finds hosts between a given IP range or single IP. Implements a multithreaded solution for a large IP address
     *  range, using up to 50 threads depending on block size.
     *
     * @param threaded Whether the function should use multithreading
     * @return ArrayList of Host objects that are connected to the network
     * @throws IOException If IP address is invalid for InetAddress
     */
    public ArrayList<Host> discoverHosts(boolean threaded) throws IOException {

        if(!validateIP(this.startIp)){
            return this.hosts;
        }

        // If single IP has been given
        if(this.endIp == null){

            // IP address representation
            InetAddress addr = null;

            try{
                addr = InetAddress.getByName(this.startIp);
            } catch (UnknownHostException e){
                System.err.println("Unknown Host: " + e);
            }

            // If host is reachable within the given timeout period, add host to list.
            if(addr != null && addr.isReachable(this.timeout)){
                this.hosts.add(new Host(this.startIp));
            }

        }
        // IP address range given
        else{

            // Gets range of Class C IP address range and calculates thread pool size
            String[] startAddrOctets = this.startIp.split("\\.");
            String[] endAddrOctets = this.endIp.split("\\.");

            int range = Integer.parseInt(endAddrOctets[3]) - Integer.parseInt(startAddrOctets[3]);

            if(range < 1) return this.hosts;

            String network = startAddrOctets[0] + "." + startAddrOctets[1] + "." + startAddrOctets[2] + ".";

            int poolSize = range / 5;
            if(poolSize > 50) poolSize = 50;

            // If multithreading should be used and poolsize is big enough to justify multithreading
            if(threaded && poolSize > 1){

                // Create thread safe List and iterated host number
                ConcurrentLinkedQueue<String> hostsToSearch = new ConcurrentLinkedQueue<>();
                ExecutorService es = Executors.newFixedThreadPool(poolSize);
                AtomicInteger hostNumber = new AtomicInteger(Integer.parseInt(startAddrOctets[3]));

                // For each host
                while(hostNumber.get() <= Integer.parseInt(endAddrOctets[3])){

                    // Concatenate network and host portion of IP address
                    final String host = network + hostNumber.getAndIncrement();

                    // Thread logic to check whether host is reachable
                    es.submit(() -> {
                        try {

                            InetAddress addr = InetAddress.getByName(host);
                            if(addr.isReachable(this.timeout)){
                                hostsToSearch.add(host);
                            }

                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }

                    });

                }

                // Shut complete threads down
                es.shutdown();
                try {
                    es.awaitTermination(5, TimeUnit.MINUTES);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // Retrieve live hosts from search queue
                while (!hostsToSearch.isEmpty()) {
                    this.hosts.add(new Host(hostsToSearch.poll()));
                }

                return this.hosts;

            }
            // Threading option disabled or poolsize too small to justify multithreading
            else {

                for (int i = 0; i < range; ++i) {

                    String ip = network + i;
                    InetAddress addr = InetAddress.getByName(ip);
                    boolean isReachable = addr.isReachable(this.timeout);

                    if (isReachable) {
                        hosts.add(new Host(ip));
                    }

                }

            }

        }

        return this.hosts;

    }

}
