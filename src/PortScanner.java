import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class PortScanner {

    public PortScanner(){}

    /**
     * Find open ports within given port range for a specified Host IP. Uses multithreading.
     * @param ip Host IP
     * @param minPort Minimum of port range
     * @param maxPort Maximum of port range
     * @param timeout Timeout (ms) for host to be resolved
     * @return ArrayList of ports open.
     */
    public static ArrayList<Integer> findOpenPorts(String ip, int minPort, int maxPort, int timeout){

        // List to store open ports of host
        ArrayList<Integer> openPorts = new ArrayList<>();

        // If host has valid IP address
        if(HostDiscovery.validateIP(ip)) {

            // poolSize increases proportionally with a max size of 100
            int portRange = maxPort - minPort;
            int poolSize = portRange / 656 * 10;

            // Limit pool size to 100
            if (poolSize > 99) {
                poolSize = 100;
            }
            // pool size will be at least 2
            else if (portRange < 100){
                poolSize = 2;
            }

            // Create thread safe port list and potnumber
            ConcurrentLinkedQueue<Integer> openPortsQueue = new ConcurrentLinkedQueue<>();
            ExecutorService es = Executors.newFixedThreadPool(poolSize);
            AtomicInteger portNumber = new AtomicInteger(minPort);

            // For each port in range
            while(portNumber.get() <= maxPort){

                final int port = portNumber.getAndIncrement();

                // Thread logic to check if port is open, using InetSocketAddress
                es.submit(() -> {
                    try{

                        Socket s = new Socket();
                        s.connect(new InetSocketAddress(ip, port), timeout);
                        openPortsQueue.add(port);

                    } catch (IOException ignored){
                    }

                });

            }

            // Shut complete threads down
            es.shutdown();
            try {
                es.awaitTermination(1, TimeUnit.MINUTES);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Retrieve open ports from Queue
            while (!openPortsQueue.isEmpty()) {
                openPorts.add(openPortsQueue.poll());
            }

        }

        return openPorts;

    }

}